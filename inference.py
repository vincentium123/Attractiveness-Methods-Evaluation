# -*- coding: utf-8 -*-
"""Inference.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1u3FT3TWXxet_eZRw6AS8YepTpR2MPspW
"""

#This is the architecture for a ComboNet model, combining a regression and a classification model
#The num_out variable refers to the number of categories the classification model should predict

import math

import torch.nn as nn
import torch.nn.functional as F
from torch.nn import init
from torchvision import models

from pytorchcv.model_provider import get_model as ptcv_get_model


class ComboNet(nn.Module):
    """
    definition of ComboNet
    """

    def __init__(self, num_out=10, backbone_net_name='SEResNeXt50'):
        super(ComboNet, self).__init__()

        if backbone_net_name == 'SEResNeXt50':
            seresnext50 = ptcv_get_model("seresnext50_32x4d", pretrained=True)
            num_ftrs = seresnext50.output.in_features
            self.backbone = seresnext50.features
        elif backbone_net_name == 'ResNet18':
            resnet18 = models.resnet18(pretrained=True)
            num_ftrs = resnet18.fc.in_features
            self.backbone = resnet18

        self.backbone_net_name = backbone_net_name
        self.regression_branch = nn.Linear(num_ftrs, 1)
        self.classification_branch = nn.Linear(num_ftrs, num_out)

    def forward(self, x):
        if self.backbone_net_name == 'SEResNeXt50':
            feat = self.backbone(x)
            feat = feat.view(-1, self.num_flat_features(feat))
        elif self.backbone_net_name == 'ResNet18':
            for name, module in self.backbone.named_children():
                if name != 'fc':
                    x = module(x)
            feat = x.view(-1, self.num_flat_features(x))

        regression_output = self.regression_branch(feat)
        classification_output = self.classification_branch(feat)

        return regression_output, classification_output

    def num_flat_features(self, x):
        size = x.size()[1:]  # all dimensions except the batch dimension
        num_features = 1
        for s in size:
            num_features *= s

        return num_features

#This code conducts inference on all the images on every subfolder in a main folder.

import sys
import time
from collections import OrderedDict
import numpy as np
import torch
import torch.nn as nn
import torchvision.transforms as transforms
from PIL import Image
from skimage import io
import os
import csv

import os
import csv

def process_folder_images(folder_path, output_csv, additional_word=""):
    fbp = FacialBeautyPredictor(pretrained_model_path='')

    with open(output_csv, 'w', newline='') as csvfile:
        writer = csv.writer(csvfile)
        writer.writerow(['file_name', 'predicted_value'])

        for file_name in os.listdir(folder_path):
            image_path = os.path.join(folder_path, file_name)

            if not is_image_file(image_path):
                continue  # Skip files that don't have the desired image file extensions

            result = fbp.infer(image_path)
            writer.writerow([file_name, result['beauty']])

def is_image_file(file_path):
    image_extensions = ['.jpg', '.png', '.gif', '.jpeg']
    _, file_extension = os.path.splitext(file_path)
    return file_extension.lower() in image_extensions




class FacialBeautyPredictor:
    """
    Facial Beauty Predictor
    """

    def __init__(self, pretrained_model_path):
        model = ComboNet(num_out=10, backbone_net_name='SEResNeXt50')
        model = model.float()
        device = torch.device('cuda:0' if torch.cuda.is_available() else 'cpu')
        model = model.to(device)

        # model.load_state_dict(torch.load(pretrained_model_path))
        def fix_state_dict(state_dict):
          new_state_dict = OrderedDict()
          for k, v in state_dict.items():
              name = k
              if name.startswith('e.'):  # remove 'e.' prefix
                  name = name[2:]  # remove `e.`
              new_state_dict[name] = v
          return new_state_dict
        if torch.cuda.device_count() > 1:
            print("We are running on", torch.cuda.device_count(), "GPUs!")
            model = nn.DataParallel(model)
            model.load_state_dict(fix_state_dict(torch.load(pretrained_model_path)))
        else:
            model.load_state_dict(fix_state_dict(torch.load(pretrained_model_path)))


        model.to(device)
        model.eval()

        self.device = device
        self.model = model

    def infer(self, img_file):
        tik = time.time()
        img = io.imread(img_file)
        img = Image.fromarray(img.astype(np.uint8))

        preprocess_large_rgb = transforms.Compose([
            transforms.ToTensor(),
            transforms.Normalize([0.485, 0.456, 0.406], [0.229, 0.224, 0.225])
        ])


        preprocess_large_grayscale = transforms.Compose([
            transforms.Grayscale(num_output_channels=3),
            transforms.ToTensor(),
            transforms.Normalize([0.485, 0.485, 0.485], [0.229, 0.229, 0.229])
        ])


        if img.mode == 'L':  # Check if the image is grayscale
              img = preprocess_large_grayscale(img)  # Apply preprocessing for large grayscale images
        else:
              img = preprocess_large_rgb(img)  # Apply preprocessing for large RGB images
        img.unsqueeze_(0) #Getting the tensor dimensions correct
        img = img.to(self.device)

        score, cls = self.model(img)
        tok = time.time()

        return {
            'beauty': float(score.to('cpu').detach().item()),
            'elapse': tok - tik
        }


if __name__ == '__main__':
    folder_path = ''  # Replace with the actual folder path containing the images
    output_folder = ''  # Specify the folder where the output CSVs will be saved
    additional_word = ''  # Specify the additional word for the output CSV file names

    #os.makedirs(output_folder, exist_ok=True)  # Create the output folder if it doesn't exist

    for root, _, _ in os.walk(folder_path):
        if root != folder_path:
            # Get the name of the current subfolder
            subfolder_name = os.path.basename(root)

            # Construct the output CSV file name
            csv_file_name = f"{subfolder_name}_{additional_word}.csv"

            # Construct the output CSV file path
            output_csv = os.path.join(output_folder, csv_file_name)

            # Process images in the current subfolder
            process_folder_images(root, output_csv)